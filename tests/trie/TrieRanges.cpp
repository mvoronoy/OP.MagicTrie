#if _MSC_VER > 1000
#pragma warning(disable:4503)
#endif // _MSC_VER > 1000

#include <op/utest/unit_test.h>
#include <op/utest/unit_test_is.h>

#include <op/ranges/OrderedRange.h>
#include <op/trie/Trie.h>
#include <op/ranges/RangeUtils.h>
#include <op/vtm/SegmentManager.h>
#include <op/vtm/CacheManager.h>
#include <op/vtm/EventSourcingSegmentManager.h>
#include <op/ranges/FlattenRange.h>
#include <op/trie/TrieRangeAdapter.h>

#include <algorithm>
#include "../test_comparators.h"
#include "../AtomStrLiteral.h"

namespace {
using namespace OP::trie;
using namespace OP::utest;
using namespace OP::flur;
const char* test_file_name = "trie.test";

template <class TStr = std::string>
struct lexicographic_less {
    bool operator() (const TStr& s1, const TStr& s2) const
    {
        return std::lexicographical_compare(s1.begin(), s1.end(), s2.begin(), s2.end());
    }
};

template <class O, class T>
void print_hex(O& os, const T& t)
{
    auto b = std::begin(t), e = std::end(t);
    for (; b != e; ++b)
        os << std::setbase(16) << std::setw(2) << std::setfill('0') << (unsigned int)(unsigned char)*b;
    os << '\n';
}
template <class Stream, class Co>
inline void print_co(Stream& os, const Co& co)
{
    for (auto i = co.begin(); co.in_range(i); co.next(i))
    {
        auto&& k = i.key();
        print_hex(os, k);
        os << '=' << *i << '\n';
    }
}

#include "TrieTestUtils.h"
#include <random>

void test_TrieSubtree(OP::utest::TestRuntime& tresult)
{

    std::random_device rd;
    std::mt19937 random_gen(rd());

    auto tmngr1 = OP::trie::SegmentManager::create_new<EventSourcingSegmentManager>(test_file_name,
        OP::trie::SegmentOptions()
        .segment_size(0x110000));
    typedef Trie<EventSourcingSegmentManager, double> trie_t;
    std::shared_ptr<trie_t> trie = trie_t::create_new(tmngr1);
    std::map<atom_string_t, double> test_values;
    // Populate trie with unique strings in range from [0..255]
    // this must cause grow of root node
    const atom_string_t stems[] = { (atom_t*)"abc", (atom_t*)"x", atom_string_t(256, 'z') };
    std::array<std::uint16_t, 255> rand_idx;
    std::iota(std::begin(rand_idx), std::end(rand_idx), 0);
    std::shuffle(std::begin(rand_idx), std::end(rand_idx), random_gen);
    auto n = 0;
    for (auto i : rand_idx)
    {
        atom_string_t root(1, (atom_string_t::value_type)i);
        decltype(root.begin()) b1;
        //for odd entries make terminal
        if ((i & 1) != 0)
        {
            auto ins_res = trie->insert(b1 = std::begin(root), std::end(root), (double)i);
            test_values[root] = (double)i;
        }
        //make inner loop to create all possible stems combinations
        for (auto j : stems)
        {
            atom_string_t test = root + j;
            //std::cout << n++ << std::endl;
            auto ins_res = trie->insert(test, (double)test.length());
            tresult.assert_true(ins_res.second);
            tresult.assert_true(tools::container_equals(ins_res.first.key(), test, &tools::sign_tolerant_cmp<atom_t>));
            test_values[test] = (double)test.length();
        }
        //std::cout << std::setfill('0') << std::setbase(16) << std::setw(2) << (unsigned)i << "\n";
    }
    compare_containers(tresult, *trie, test_values);
    trie.reset();
    tmngr1 = OP::trie::SegmentManager::open<EventSourcingSegmentManager>(test_file_name);
    trie = trie_t::open(tmngr1);
    //
    compare_containers(tresult, *trie, test_values);
    //std::cout << "trie:\n";
    //for (const auto& i : trie->range())
    //{
    //    print_hex(std::cout << "\t", i.key().substr(0, 48));
    //}
    std::set<atom_string_t> sorted_checks(std::begin(stems), std::end(stems));
    for (auto i : rand_idx)
    {
        atom_string_t test = atom_string_t(1, (std::string::value_type)i);

        auto container_range = trie->prefixed_range(test);

        //std::cout << "querying:";
        //print_hex(std::cout, test);
        //std::cout << "@@>\n";
        //auto ix = container_range.compound();
        //for (ix.start(); ix.in_range(); ix.next())
        //{
        //    const auto& k = ix.current().key();
        //    print_hex(std::cout << "\t", k);
        //    std::cout << '=' << ix.current().value() << '\n';
        //}
        //std::cout <<"<@@\n";
        auto begin_test = container_range.compound();

        begin_test.start();
        if ((i & 1) != 0) //odd entries must have a terminal
        {
            auto local_res = begin_test.current();
            tresult.assert_true(
                tools::container_equals(local_res.key(), test, &tools::sign_tolerant_cmp<atom_t>));

            tresult.assert_true(local_res.value() == (double)i);
            begin_test.next();
        }
        auto a = std::begin(sorted_checks);
        auto cnt = 0;
        for (; begin_test.in_range(); begin_test.next(), ++a, ++cnt)
        {
            auto strain_str = (test + *a);
            auto local_res = begin_test.current();
            //print_hex(tresult.debug() << "1)", strain_str);
            //print_hex(tresult.debug() << "2)", begin_test.key());
            tresult.assert_true(tools::container_equals(local_res.key(), strain_str), "! strain == prefix");
            tresult.assert_true(local_res.value() == (double)strain_str.length());
        }
        tresult.assert_true(a == sorted_checks.end());
        tresult.assert_true(cnt > 0);
    }
}

template <class R1, class R2, class Sample>
void test_join(
    OP::utest::TestRuntime& tresult, R1 r1, R2 r2, const Sample& expected)
{
    using namespace OP::flur;

    auto cmp = [](const auto& left, const auto& right)->int {
        return left.first.compare(right.second);
    };
    auto result1 = r1 >> then::join(r2, cmp);

    tresult.assert_that<eq_sets>(result1, expected, OP_CODE_DETAILS());

    auto result2 = r2 >> then::join(r1, cmp);
    tresult.assert_that<eq_sets>(result2, expected, OP_CODE_DETAILS());
}
void test_TrieSubtreeLambdaOperations(OP::utest::TestRuntime& tresult)
{
    auto tmngr1 = OP::trie::SegmentManager::create_new<EventSourcingSegmentManager>(test_file_name,
        OP::trie::SegmentOptions()
        .segment_size(0x110000));
    typedef Trie<EventSourcingSegmentManager, double> trie_t;
    std::shared_ptr<trie_t> trie = trie_t::create_new(tmngr1);
    // Populate trie with unique strings in range from [0..255]
    // this must cause grow of root node
    const atom_string_t stems[] = {
        "adc"_atom,
        "x"_atom,
        atom_string_t(256, 'a'),
        atom_string_t(256, 'a') + (atom_t*)("b")
    };
    auto n = 0;
    for (auto i : stems)
    {
        auto ins_res = trie->insert(i, (double)i.length());
        tresult.assert_true(ins_res.second);
        tresult.assert_true(tools::container_equals(ins_res.first.key(), i, &tools::sign_tolerant_cmp<atom_t>));

        //std::cout << std::setfill('0') << std::setbase(16) << std::setw(2) << (unsigned)i << "\n";
    }
    std::map<atom_string_t, double> test_values;
    auto pair_extractor = [](const auto& i) {
        using p_t = decltype(test_values)::value_type;
        return p_t(i.key(), *i);
    };
    atom_string_t query1("a"_atom);
    atom_string_t query2("ad"_atom);
    auto container1 = trie->prefixed_range(query1);
    auto container2 = trie->prefixed_range(query2);

    auto cnt_join = (container1 & container2)
        >> then::mapping(pair_extractor);
    //tresult.info() << "====== container:2\n";
    //container2->for_each([&tresult](auto& i) {
    //    print_hex(tresult.info(), i.key());
    //});
    test_values.emplace(stems[0], 3.);

    tresult.assert_that<eq_sets>(cnt_join, test_values, OP_CODE_DETAILS());
    tresult.assert_that<eq_sets>((container2 & container1)
        >> then::mapping(pair_extractor), test_values, OP_CODE_DETAILS());
    //
    //  Test empty
    //
    test_values.clear();
    atom_string_t query3("x"_atom);
    auto tst_r1 = trie->prefixed_range(std::begin(query3), std::end(query3));
    tresult.assert_that<eq_sets>(
        (container1 & tst_r1) >> then::mapping(pair_extractor), 
        test_values,
        OP_CODE_DETAILS()
        );
    tresult.assert_that<eq_sets>(
        (tst_r1 & container1) >> then::mapping(pair_extractor), 
        test_values,
        OP_CODE_DETAILS()
        );

    const atom_string_t stem_diver[] = {
        "ma"_atom,
        "madc"_atom,
        "mb"_atom,
        "mdef"_atom,
        "mg"_atom,
        "ma"_atom,
        "madc"_atom,
        "mb"_atom,
        "mdef"_atom,
        "ng"_atom,
        "na"_atom,
        "nad"_atom, //missed
        "nadc"_atom,
        "nb"_atom,
        "ndef"_atom,
        "nh"_atom,
        "x"_atom
    };
    std::for_each(std::begin(stem_diver), std::end(stem_diver), [&trie](const atom_string_t& s) {
        trie->insert(s, (double)s.length());
        });
    std::map<atom_string_t, double> join_src = {
        {"mdef"_atom, 4},
        {"mg"_atom, 2},
        {"ma"_atom, 2},
        {"madc"_atom, 4},
        {"mb"_atom, 2},
        {"mdef"_atom, 4},
        {"ng"_atom, 2},
        {"na"_atom, 2},
        {"nadc"_atom, 4},
        {"nb"_atom, 2},
        {"y"_atom, 1}
    };
    auto join_src_range = OP::flur::src::of_container(join_src);

    test_values.emplace("mdef"_atom, 4);
    test_values.emplace("mg"_atom, 2);
    test_values.emplace("ma"_atom, 2);
    test_values.emplace("madc"_atom, 4);
    test_values.emplace("mb"_atom, 2);
    test_values.emplace("mdef"_atom, 4);
    /*test_values.emplace("ng"_atom, 2);
    test_values.emplace("na"_atom, 2);
    test_values.emplace("nadc"_atom, 4);
    test_values.emplace("nb"_atom, 2);*/

    atom_string_t query4("m"_atom), query5("a"_atom);
    
    //tresult.assert_that<eq_sets>(
    //    trie->prefixed_range(query4) 
    //    >> then::join(join_src_range, [](const auto& i, const auto& pr) 
    //        {return i.key().compare(pr.first); })
    //    >> then::mapping(pair_extractor),
    //    test_values);
    //tresult.assert_that<eq_sets>(
    //    join_src_range 
    //    >> then::join(trie->prefixed_range(query4), [](const auto& pr, const auto& i) 
    //        {return i.key().compare(pr.first); }) 
    //    ,
    //    test_values);

    test_values.clear();
    //tresult.assert_that<eq_sets>(
    //    trie->prefixed_range(query5)
    //    >> then::join(join_src_range, [](const auto& i, const auto& pr)
    //        {return -1; }//!@ {return i.key().compare(pr.first); }
    //    )         
    //    >> then::mapping(pair_extractor),
    //    
    //    test_values, 
    //    OP_CODE_DETAILS());
}

void test_Flatten(OP::utest::TestRuntime& tresult)
{
    using namespace OP::flur;
    auto tmngr = OP::trie::SegmentManager::create_new<EventSourcingSegmentManager>(test_file_name,
        OP::trie::SegmentOptions()
        .segment_size(0x110000));

    typedef Trie<EventSourcingSegmentManager, double> trie_t;
    std::shared_ptr<trie_t> trie = trie_t::create_new(tmngr);

    typedef std::pair<const atom_string_t, double> p_t;
    /*Test data organized as group of prefixes each owns by 3 suffixes that intersect and have corresponding suffixes as well*/
    const p_t ini_data[] = {
        p_t((atom_t*)"1.abc", 10.0),
        p_t((atom_t*)"1.bcd", 10.0),
        p_t((atom_t*)"1.def", 10.0),

        p_t((atom_t*)"2.def", 20.0),
        p_t((atom_t*)"2.fgh", 20.0),
        p_t((atom_t*)"2.hij", 20.0),

        p_t((atom_t*)"3.hij", 30.0),
        p_t((atom_t*)"3.jkl", 30.0),
        p_t((atom_t*)"3.lmn", 30.0),

        p_t((atom_t*)"4.lmn", 0.0),
        p_t((atom_t*)"4.", -1.),//empty suffix

        //block of suffixes
        p_t((atom_t*)"abc", 1.0),
        p_t((atom_t*)"bcd", 1.0),
        p_t((atom_t*)"def", 1.5), //common suffix

        p_t((atom_t*)"fgh", 2.0),
        p_t((atom_t*)"hij", 2.5), //common suffix

        p_t((atom_t*)"jkl", 3.0),
        p_t((atom_t*)"lmn", 3.5) //common suffix for 3. & 4.
    };
    std::for_each(std::begin(ini_data), std::end(ini_data), [&trie](const p_t& s) {
        trie->insert(s.first, s.second);
        });
    auto _1_range = trie->prefixed_range(atom_string_t((atom_t*)"1."));
    std::for_each(_1_range, [](const auto& i) {
        std::cout << "{" << (const char*)i.key().c_str() << " = " << i.value() << "}\n";
        });
    auto suffixes_range = _1_range 
        >> then::mapping([](const auto& i)->atom_string_t {
        return i.key().substr(2/*"1."*/);
        });
    std::for_each(suffixes_range, [&](const auto& i) {
        tresult.debug() << "{" << (const char*)i.c_str() << "}\n";
        });
    //-->>>>
    auto frange1 = suffixes_range >> then::flat_mapping(
        [&trie](const auto& i) {
        return trie->prefixed_range(i);
        });
    std::cout << "Flatten result:\n";
    std::for_each(frange1, [](const auto& i) {
        std::cout << "{" << (const char*)i.key().c_str() << ", " << i.value() << "}\n";
        });
    auto _1_flatten = suffixes_range 
        >> then::flat_mapping(
        [&trie](const auto& i) {
            return trie->prefixed_range(i);
        }) 
        >> then::mapping([](const auto& i) {
            return p_t(i.key(), i.value());
        });
    std::map<atom_string_t, double> strain1 = {

        decltype(strain1)::value_type((atom_t*)"abc", 1.0),
        decltype(strain1)::value_type((atom_t*)"bcd", 1.0),
        decltype(strain1)::value_type((atom_t*)"def", 1.5),
    };
    tresult.assert_that<eq_sets>(_1_flatten, strain1, OP_CODE_DETAILS(<< "Simple flatten failed"));
    tresult.debug() << "Scenario #2\n";

    typedef std::map<atom_string_t, double/*, lex_less*/> test_container_t;
    test_container_t src1 = {
        {"1."_atom, 1.0},
        {"2."_atom, 2.0},
        {"3."_atom, 3.0}
    };
    
    auto fres2 = src::of_container(src1)
        >> then::flat_mapping(
        [&trie](const auto& i) {

        return trie
            ->prefixed_range(i.first)
            /*[!] Uncoment to test compile time error "DeflateFunction must produce range that support ordering"
            ->map([&k](const auto& i) {
                return OP::ranges::key_discovery::key(i).substr(k.length());
            }) */
            ;
        })
        >> then::mapping([](const auto&i) {
            return p_t(i.key(), i.value());
        })
        ;

    test_container_t strain_fm = {
        { "1.abc"_astr, 10.000000 },
        { "1.bcd"_astr, 10.000000 },
        { "1.def"_astr, 10.000000 },
        { "2.def"_astr, 20.000000 },
        { "2.fgh"_astr, 20.000000 },
        { "2.hij"_astr, 20.000000 },
        { "3.hij"_astr, 30.000000 },
        { "3.jkl"_astr, 30.000000 },
        { "3.lmn"_astr, 30.000000 },
    };
    std::for_each(fres2, [&](const auto& i) {
        //tresult.debug() << "\\/{" << i.key() << ", " << *i << "}\\/\n";
        });
    tresult.assert_that<eq_sets>(
        fres2, strain_fm, OP_CODE_DETAILS());

}

//void test_TrieSectionRange(OP::utest::TestRuntime& tresult)
//{
//
//    auto tmngr = OP::trie::SegmentManager::create_new<EventSourcingSegmentManager>(test_file_name,
//        OP::trie::SegmentOptions()
//        .segment_size(0x110000));
//
//    typedef Trie<EventSourcingSegmentManager, double> trie_t;
//    std::shared_ptr<trie_t> trie = trie_t::create_new(tmngr);
//
//    typedef std::pair<atom_string_t, double> p_t;
//
//    const p_t ini_data[] = {
//        p_t("1.abc"_astr, 1.0),
//        p_t("1.abc.1"_astr, 1.1),
//        p_t("1.abc.2"_astr, 1.2),
//        p_t("1.abc.3"_astr, 1.3),
//        p_t("1.def.1"_astr, 1.4),
//        p_t("1.def"_astr, 1.5),
//        p_t("1."_astr, 1.5),
//
//        p_t("2.abc"_astr, 2.0),
//        p_t("2.abc.1"_astr, 2.0),
//        p_t("2."_astr, 2.0),
//
//        p_t("3.abc"_astr, 3.1),
//        p_t("3.abc.3"_astr, 3.2),
//        p_t("3."_astr, 3.0),
//
//        p_t("4."_astr, 4.0)
//    };
//
//    std::for_each(std::begin(ini_data), std::end(ini_data), [&](const p_t& s) {
//        trie->insert(s.first, s.second);
//        });
//
//    tresult.debug() << "Test no suffixes with terminal string without branching\n";
//    auto _1r = trie->section_range("4."_astr);
//    tresult.assert_false(_1r->in_range(_1r->begin()), "Suffix of terminal string without branching must be empty");
//
//    tresult.debug() << "Test base scenario\n";
//    auto _2r = trie->section_range("1."_astr);
//    std::map<atom_string_t, double> strain1 = {
//        p_t("abc"_astr, 1.0),
//        p_t("abc.1"_astr, 1.1),
//        p_t("abc.2"_astr, 1.2),
//        p_t("abc.3"_astr, 1.3),
//        p_t("def.1"_astr, 1.4),
//        p_t("def"_astr, 1.5),
//    };
//    //_2r->for_each([](const auto& i) {
//    //    std::cout << "{" << (const char*)i.key().c_str() << ", " << *i << "}\n";
//    //});
//    tresult.assert_true(
//        OP::ranges::utils::map_equals(*_2r, strain1), OP_CODE_DETAILS(<< "Simple section failed"));
//
//    std::map<atom_string_t, double> strain2 = {
//        p_t(".1"_astr, 1.1),
//        p_t(".2"_astr, 1.2),
//        p_t(".3"_astr, 1.3)
//
//    };
//    auto _3r = trie->section_range("1.abc"_astr);
//    tresult.assert_true(
//        OP::ranges::utils::map_equals(*_3r, strain2), OP_CODE_DETAILS(<< "Narrowed section failed"));
//
//    tresult.debug() << "Test flatten-range scenario\n";
//    auto lookup = trie->sibling_range("1."_astr);
//    lookup->for_each([](const auto& i) {
//        std::cout << "////" << (const char*)i.key().c_str() << ", " << i.value() << "}\n";
//        });
//    auto _4r = trie->sibling_range("1."_astr)->flatten([&](auto const& i) {
//        return trie->section_range(i.key());
//        });
//    std::map<atom_string_t, std::set<double>> strain4 = {
//        {"abc"_astr, {1, 2, 3.1}},
//        {"abc.1"_astr, {1.1, 2}},
//        {"abc.2"_astr, {1.2}},
//        {"abc.3"_astr, {3.2, 1.3}},
//        {"def"_astr, {1.5}},
//        {"def.1"_astr, {1.4}}
//    };
//    size_t n = 0;
//    const size_t n4r = _4r->count();
//    tresult.assert_that<greater>(n4r, 0, OP_CODE_DETAILS(<< "Flatten range must not be empty"));
//    _4r->for_each([&](const auto& i) {
//        std::cout << "{" << (const char*)i.key().c_str() << "=" << i.value() << "}\n";
//        //need manually compare
//        auto& key = i.key();
//        auto value = i.value();
//        auto found = strain4.find(key);
//        tresult.assert_that<logical_not<equals>>(strain4.end(), found, OP_CODE_DETAILS(<< "Key not found:" << (const char*)key.c_str()));
//        auto& value_set = found->second;
//        tresult.assert_that<equals>(key, found->first, OP_CODE_DETAILS(<< "Key compare failed:" << (const char*)key.c_str()));
//        tresult.assert_that<logical_not<equals>>(value_set.end(), value_set.find(value),
//            OP_CODE_DETAILS(<< "Value compare failed:" << value << " of key:" << (const char*)key.c_str()));
//        ++n;
//        value_set.erase(value);
//        if (value_set.empty())
//            strain4.erase(found);
//        });
//    tresult.assert_that<equals>(n, n4r, OP_CODE_DETAILS(<< "Result sets are not equal size:" << n << " vs " << n4r));
//}


void test_ChildSelector(OP::utest::TestRuntime& tresult)
{
    auto tmngr = OP::trie::SegmentManager::create_new<EventSourcingSegmentManager>(test_file_name,
        OP::trie::SegmentOptions()
        .segment_size(0x110000));

    typedef Trie<EventSourcingSegmentManager, double> trie_t;
    std::shared_ptr<trie_t> trie = trie_t::create_new(tmngr);

    typedef std::pair<const atom_string_t, double> p_t;
    auto pair_extractor = [](const auto& i) {
        return p_t(i.key(), *i);
    };

    const p_t ini_data[] = {
        p_t((atom_t*)"abc", 1.),
        p_t((atom_t*)"abc.1", 1.),
        p_t((atom_t*)"abc.2", 1.),
        p_t((atom_t*)"abc.3", 1.3),
        p_t((atom_t*)"abc.333", 1.33),
        p_t((atom_t*)"abd", 2.0)
    };
    std::map<atom_string_t, double> test_values;
    std::for_each(std::begin(ini_data), std::end(ini_data), [&](const p_t& s) {
        trie->insert(s.first, s.second);
        test_values.emplace(s.first, s.second);
        });
    tresult.info() << "first/last child\n";
    auto i_root = trie->find("abc"_astr);
    auto last_ch1 = trie->last_child(i_root);
    tresult.assert_that<equals>(last_ch1.key(), "abc.3"_astr, "key mismatch");
    tresult.assert_that<equals>(*last_ch1, 1.3, "value mismatch");
    auto first_ch1 = trie->first_child(i_root);//of 'abc'
    tresult.assert_that<equals>(first_ch1.key(), "abc.1"_astr, "key mismatch");
    tresult.assert_that<equals>(*first_ch1, 1., "value mismatch");

    auto last_ch1_3 = trie->last_child(last_ch1);
    tresult.assert_that<equals>((++last_ch1).key(), "abc.333"_astr, "origin iterator must not be changed while `last_child`");
    tresult.assert_that<equals>(last_ch1_3.key(), "abc.333"_astr, "next key mismatch");
    tresult.assert_that<equals>(*last_ch1_3, 1.33, "value mismatch");
    //check no-child case
    auto i_2 = trie->find(std::string("abc.2"));
    auto last_ch2 = trie->last_child(i_2);
    tresult.assert_that<equals>(last_ch2, trie->end(), "no-child case failed");
    auto first_ch2 = trie->first_child(i_2);
    tresult.assert_that<equals>(first_ch2, trie->end(), "no-child case failed");
    //check end() case
    auto i_3 = trie->find(std::string("x"));
    auto last_ch_end = trie->last_child(i_3);
    tresult.assert_that<equals>(last_ch_end, trie->end(), "end() case failed");
    auto first_ch_end = trie->first_child(i_3);
    tresult.assert_that<equals>(first_ch_end, trie->end(), "end() case failed");

    auto f_root = trie->find(std::string("abc.1"));
    auto first_ch1_end = trie->first_child(f_root);
    tresult.assert_that<equals>(first_ch1_end, trie->end(), "end() case failed");

    tresult.info() << "children ranges\n";
    auto r1 = trie->children_range(i_root);

    std::map<atom_string_t, double> r1_test{
        ini_data[1],
        ini_data[2],
        ini_data[3] };
    // .333 is not a direct child
    //r1_test.emplace(std::string(ini_data[4].first.begin(), ini_data[4].first.end()), ini_data[4].second);

    tresult.assert_that<eq_sets>(
        r1 >> then::mapping(pair_extractor), 
        r1_test, OP_CODE_DETAILS());

    auto r2 = trie->children_range(i_3);  //end()
    std::map<atom_string_t, double> r2_empty;
    tresult.assert_that<eq_sets>(
        r2>> then::mapping(pair_extractor), 
        r2_empty, 
        OP_CODE_DETAILS());

}

void test_Range(OP::utest::TestRuntime& tresult)
{
    using namespace OP::flur;
    auto tmngr = OP::trie::SegmentManager::create_new<EventSourcingSegmentManager>(test_file_name,
        OP::trie::SegmentOptions()
        .segment_size(0x110000));
    typedef Trie<EventSourcingSegmentManager, double> trie_t;
    std::shared_ptr<trie_t> trie = trie_t::create_new(tmngr);

    typedef std::pair<atom_string_t, double> p_t;
    std::map<atom_string_t, double> test_values;

    const p_t ini_data[] = {
        p_t((atom_t*)"a1", 1.),
        p_t((atom_t*)"a2", 1.),
        p_t((atom_t*)"xyz", 1.),
        p_t((atom_t*)"klmnopqrstuffjfisdifsd sduf asdasjkdhasjhjkahaskdask asaskdhaskhdkasdasjdasjkdhaskasdjk hkasdjhdkashaskdaksdasjkhdjkash djkashkdashjkdhasjkhdkashdjkashdjkasklmnopqrstuffjfisdifsd sduf asdasjkdhasjhjkahaskdask asaskdhaskhdkasdasjdasjkdhaskasdjk hkasdjhdkashaskdaksdasjkhdjkash djkashkdashjkdhasjkhdkashdjkashdjkas", 11.1),
        p_t((atom_t*)"bc", 1.),
        p_t((atom_t*)"bc.12", 1.),
        p_t((atom_t*)"bc.122x", 1),
        p_t((atom_t*)"bc.123456789", 1),
        p_t((atom_t*)"bd.12", 1.),
    };
    std::for_each(std::begin(ini_data), std::end(ini_data), [&](const p_t& s) {
        trie->insert(s.first, s.second);
        test_values.emplace(s.first, s.second);
        });

    auto i = test_values.begin();

    auto rrange9 = (
        trie->range() 
        >> then::mapping([&](auto const& kv) {
        tresult.assert_true(tools::container_equals(kv.key(), i->first, &tools::sign_tolerant_cmp<atom_t>),
            OP_CODE_DETAILS(<< "error for key=" << (const char*)i->first.c_str() << ", while obtained:" << (const char*)kv.key().c_str()));
        tresult.assert_that<equals>(kv.value(), i->second,
            OP_CODE_DETAILS(<< "Associated value error, has:" << kv.value() << ", expected:" << i->second));
        ++i; 
        return 0;//just dummy result to allow count
        })).compound();
    auto n = std::distance(rrange9.begin(), rrange9.end());
    tresult.assert_that<equals>(9, n, "wrong counter");
    //test take_while semantic
    auto range_rest = (trie->range()
    >> then::take_awhile([&](auto const& kv)->bool {
        return kv.key()[0] <= (atom_t)'b';
    })).compound();

    tresult.assert_that<equals>(7, std::distance(range_rest.begin(), range_rest.end()), "wrong counter");
}
void test_NativeRangeSupport(OP::utest::TestRuntime& tresult)
{
    using namespace OP::flur;
    tresult.info() << "apply lower_bound on container with native support\n";
    std::map<atom_string_t, double> src1;
    src1.emplace("a"_atom, 1.0);
    src1.emplace("ab"_atom, 1.0);
    src1.emplace("b"_atom, 1.0);
    src1.emplace("bc"_atom, 1.0);
    src1.emplace("c"_atom, 1.0);
    src1.emplace("cd"_atom, 1.0);
    src1.emplace("d"_atom, 1.0);
    src1.emplace("def"_atom, 1.0);
    src1.emplace("g"_atom, 1.0);
    src1.emplace("xyz"_atom, 1.0);

    //note: no transactions!
    auto tmngr1 = OP::trie::SegmentManager::create_new<OP::trie::SegmentManager>("trie2range.test",
        OP::trie::SegmentOptions()
        .segment_size(0x110000));

    using trie_t = OP::trie::Trie<OP::trie::SegmentManager, double>;
    std::shared_ptr<trie_t> trie = trie_t::create_new(tmngr1);
    for (const auto& pair : src1) trie->insert(pair.first, pair.second);
    auto g_pos = trie->find("g"_astr);
    auto flt_src = (trie
        ->range()
        //>> then::filter([](const auto& it) { return it.key().length() > 1/*peek long enough*/; })
        ).compound();
    flt_src.next_lower_bound_of(g_pos); //pretty sure 'f' not exists so correct answer are 'g' and 'xyz', but filter skips (len > 1)
    tresult.assert_true(flt_src.in_range(), OP_CODE_DETAILS(<< "end of the range is wrong"));

    tresult.assert_that<equals>(
        flt_src.current().key(),
        "g"_atom,
        OP_CODE_DETAILS(<< "lower_bound must point 'XYZ'")
        );
}



template <class Range1, class Range2, class Vector>
std::int64_t applyJoinRest(Range1 range1, Range2 range2, Vector &result)
{

    auto join_result = (range1 >> OP::flur::then::join(range2)).compound();
    
    std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();
    //materialize
    std::copy(join_result.begin(), join_result.end(), std::back_inserter(result));
    std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();
    
    auto retval = std::chrono::duration_cast<std::chrono::milliseconds>(end - begin).count();
    return retval;
}

void test_JoinRangeOverride(TestRuntime& tresult)
{
    using namespace OP::flur;

    auto tmngr1 = OP::trie::SegmentManager::create_new<EventSourcingSegmentManager>(test_file_name,
        OP::trie::SegmentOptions()
        .segment_size(0x110000));
    auto tmngr2 = OP::trie::SegmentManager::create_new<EventSourcingSegmentManager>((std::string("2_")+test_file_name).c_str(),
        OP::trie::SegmentOptions()
        .segment_size(0x110000));
    auto tmngr3 = OP::trie::SegmentManager::create_new<EventSourcingSegmentManager>((std::string("3_") + test_file_name).c_str(),
        OP::trie::SegmentOptions()
        .segment_size(0x110000));

    typedef Trie<EventSourcingSegmentManager, size_t> trie_t;
    tresult.info()<<"create trie #1...\n";
    std::shared_ptr<trie_t> trie1 = trie_t::create_new(tmngr1);

    tresult.info()<<"create trie #2...\n";
    std::shared_ptr<trie_t> trie2 = trie_t::create_new(tmngr2);

    tresult.info()<<"create trie #3...\n";
    std::shared_ptr<trie_t> trie3 = trie_t::create_new(tmngr3);

    typedef std::pair<atom_string_t, size_t> p_t;
    std::map<atom_string_t, size_t> test_values;
    //create low-density trie
    constexpr size_t avg_str_len = 11;
    constexpr size_t trie_limit = 5000;
    atom_string_t rnd_val;
    rnd_val.reserve(avg_str_len);
    static const atom_string_t rand_str_base = "0123456789"\
                    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"\
                    "abcdefghijklmnopqrstuvwxyz"_astr;
    for (size_t i = 0; i < trie_limit; ++i)
    {
        tresult.debug()<<".";
        if((i % 32) == 0 )
            tresult.debug()<<i<<"\n";
        auto& rnds = OP::utest::tools::RandomGenerator::instance();
        rnds.random_field(rnd_val, rand_str_base, avg_str_len, avg_str_len);

        trie1->insert(rnd_val, i);
        tresult.debug()<<":";
        if(((int)rnd_val[0]) % 2 == 0 )
            trie2->insert(rnd_val, i);
        if( ((int)rnd_val[0]) % 3 == 0)
            trie3->insert(rnd_val, i);
        test_values.emplace(rnd_val, i);
    }
    tresult.info()<<"\nDone populating #1, #2, #3 \n Compare with test-values...";
    compare_containers(tresult, *trie1, test_values);

    //thin-out map for later compare
    for (auto iter = test_values.begin(); iter != test_values.end(); ) {
        if ((iter->first[0] %2) != 0 || (iter->first[0] % 3) != 0)  {
            iter = test_values.erase(iter);
        }
        else {
            ++iter;
        }
    }
    using target_t = std::vector<std::pair<atom_string_t, size_t>>;
    target_t result1; 
    target_t result2;
    result1.reserve(100 + trie_limit / 3);
    result2.reserve(100 + trie_limit / 3);

    tresult.info()<<"Create filtered sub-range-1 for trie #1\n";
    auto t1r1 = trie1->range() >> then::filter([&](const auto& i) {
        return ((int)i.key()[0]) % 2 == 0;
        });
    tresult.info()<<"Create filtered sub-range-2 for trie #1\n";
    auto t1r2 = trie1->range() >> then::filter([&](const auto& i) {
        return ((int)i.key()[0]) % 3 == 0;
        });
    // filtered range uses default impl of join
    //tresult.info() << "Join processed:" << applyJoinRest(
    //    t1r1,
    //    t1r2,
    //    result1) << "[ms]\n";
    auto inr1 = t1r1
        >> then::join(t1r2);
    //compare_containers(tresult,
    //    (   inr1
    //        >> then::mapping([](const auto& i) {
    //            using pr_t = typename decltype(test_values)::value_type;
    //            return pr_t(i.key(), i.value()); 
    //        })),
    //    test_values);
    //tresult.info() << "Splitted-default join processed:" << applyJoinRest(
    //    trie2->range() >> then::filter([](const auto&){return true;}),
    //    trie3->range() >> then::filter([](const auto&) {return true;}),
    //    result2) << "[ms]\n";
    //result2.clear();
    //// trie-range uses overriding impl of join
    //tresult.info() << "Non-default join processed:" << applyJoinRest(
    //    trie2->range(),
    //    trie3->range(),
    //    result2) << "[ms]\n";

    //tresult.assert_true(result1 == result2);
    //auto t2r1 = trie2->range() >> then::join(trie3->range());
    //compare_containers(tresult, t2r1, test_values);

}
//void test_AllPrefixesRange(OP::utest::TestRuntime& tresult) {
//    
//    using namespace OP::flur;
//
//    auto tmngr = OP::trie::SegmentManager::create_new<EventSourcingSegmentManager>(test_file_name,
//        OP::trie::SegmentOptions()
//        .segment_size(0x110000));
//
//    typedef Trie<EventSourcingSegmentManager, double> trie_t;
//    std::shared_ptr<trie_t> trie = trie_t::create_new(tmngr);
//    using testmap_t = std::map<atom_string_t, double, lexicographic_less<atom_string_t> >;
//    using testset_t = std::set<atom_string_t, lexicographic_less<atom_string_t> >;
//    auto map_cast = [](const auto& i) {
//        using p_t = typename testmap_t::value_type;
//        return p_t(i.key(), i.value());
//    };
//    testmap_t test_values{
//        {"a"_astr, 1.},
//        {"aa"_astr, 1.1},
//        {"abc"_astr, 1.2},
//        {"abca"_astr, 1.2},
//        {"abd"_astr, 1.2},
//    };
//
//    for(const auto& pair : test_values){
//        trie->insert(pair.first, pair.second);
//    };
//    auto arg_range = src::of_container(testset_t{{"a"_astr}});
//    auto inm = OP::trie::prefixes_continuation_range(trie->range(), arg_range)
//        //>> then::mapping(map_cast)
//        ;
//    for (const auto& x : inm)
//        std::cout << (const char*)x.key().c_str() << "\n";
//    tresult.assert_that<eq_sets>(
//        OP::trie::prefixes_continuation_range (trie->range(), arg_range)
//        >> then::mapping(map_cast)
//        , 
//        test_values,
//        OP_CODE_DETAILS()
//        );
//
//    arg_range = src::of_container(testmap_t{ {"ab"_astr, 2.0} });
//    tresult.assert_that<eq_sets>(
//        OP::trie::prefixes_continuation_range(trie->range(), arg_range)
//        >> then::mapping(map_cast),
//        testmap_t{ 
//            {"abc"_astr, 1.2},
//            {"abca"_astr, 1.2},
//            {"abd"_astr, 1.2},
//        });
//
//    arg_range = src::of_container(testmap_t{ {"0"_astr, 2.0}, {"aa"_astr, 2.0}, {"abcd"_astr, 2.0}, });
//    tresult.assert_that<eq_sets>( 
//        OP::trie::prefixes_continuation_range(
//            trie->range(), arg_range)
//        >> then::mapping(map_cast),
//        testmap_t{
//            {"aa"_astr, 1.1},
//        });
//
//    testmap_t suffixes { {"aaa"_astr, 1.1},
//        {"b"_astr, 1.2},
//        {"ba"_astr, 1.2},
//        {"bax"_astr, 1.2},
//        {"x"_astr, 1.2},
//        {"xy"_astr, 1.2},
//    };
//    test_values.clear();
//    const auto control_pref = "klm"_astr;
//    for(auto& s : {"k"_astr, "l"_astr, "m"_astr, "n"_astr })
//    {   //create bunch of similar prefixes
//        auto root_pair = trie->insert(s, 1.0);
//        bool is_in_control = control_pref.find(s[0]) != control_pref.npos;
//        if(is_in_control)
//            test_values.emplace(s, 1.0);
//        for(const auto& ent : suffixes){
//            auto sufix_pair = trie->prefixed_insert(root_pair.first, ent.first, ent.second);
//            auto long_suffix_pair = trie->prefixed_insert(sufix_pair.first, "aa"_astr, 1.3);
//            if (is_in_control)
//            {
//                test_values.emplace(sufix_pair.first.key(), sufix_pair.first.value());
//                test_values.emplace(long_suffix_pair.first.key(), long_suffix_pair.first.value());
//            }
//        }
//    }
//    arg_range = src::of_container(
//        testmap_t{ {"0"_astr, 2.0}, {"k"_astr, 2.0}, {"l"_astr, 2.0}, {"m"_astr, 2.0}, {"x"_astr, 2.0} });
//    //atom_string_t previous;
//    //OP::trie::prefixes_continuation_range(trie->range(), arg_range)->for_each([&tresult](const auto& i){
//    //    tresult.debug() <<"{" << (const char*)i.key().c_str() << " = " << i.value() << "}\n";
//    //    });
//    tresult.assert_that<eq_sets>( 
//        OP::trie::prefixes_continuation_range(trie->range(), arg_range)
//        >> then::mapping(map_cast), 
//        test_values);
//
//    //erase from test_values all started with 'l' or not containing 'ba'
//    for(auto er = test_values.begin(); er !=test_values.end(); )
//    {
//        if( er->first.find("l"_astr) == 0 || er->first.find("ba"_astr) == er->first.npos)
//            er = test_values.erase(er);
//        else
//            ++er;
//    }
//    arg_range = src::of_container(
//        testmap_t{ {"0ba"_astr, 2.0}, {"kba"_astr, 2.0}, {"mba"_astr, 2.0}, {"xba"_astr, 2.0} });
//    tresult.assert_that<eq_sets>( 
//        OP::trie::prefixes_continuation_range(trie->range(), arg_range)
//        >> then::mapping(map_cast), 
//        test_values
//        );
//    //just curious ....
//    auto k_range = 
//        make_mixed_sequence_factory(std::static_pointer_cast<trie_t const>(trie),
//            typename Ingredient<trie_t>::PrefixedBegin("k"_astr),
//            typename Ingredient<trie_t>::PrefixedLowerBound("k"_astr),
//            typename Ingredient<trie_t>::PrefixedInRange(StartWithPredicate("k"_astr)))
//        ;
//    for (auto er = test_values.begin(); er != test_values.end(); )
//    {
//        if (er->first.find("k"_astr) != 0 )
//            er = test_values.erase(er);
//        else
//            ++er;
//    }
//    auto cont_set = src::of_container(testset_t{ 
//        "0ba"_astr, "kba"_astr, "mba"_astr, "xba"_astr });
//
//    tresult.assert_that<eq_sets>( 
//        OP::trie::prefixes_continuation_range(k_range, cont_set)
//        >> then::mapping(map_cast)
//        , 
//        test_values, OP_CODE_DETAILS());
//}

void test_ISSUE_0001(OP::utest::TestRuntime& tresult) {
    OP::trie::atom_string_t source_seq[] = {
        { 0x13,0x04,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96 },
        { 0x14,0x44,0xa2,0xfa,0xdb,0x41,0xa1,0xd8,0x45,0xe0,0x12,0xfe,0x98,0x10,0x4d,0x55,0x87,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x00,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa,0x94,0x44,0xa2,0xfa,0xdb,0x41,0xa1,0xd8,0x45,0xe0,0x12,0xfe,0x98,0x10,0x4d,0x55,0x87 },
        { 0x02,0x04,0xab,0x0b,0xad,0x8a,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x34,0x81,0x92,0x1e },
        { 0x14,0x73,0x35,0xd0,0x43,0x41,0xb7,0xd8,0x45,0x00,0x12,0xfe,0x98,0xf2,0x2d,0x17,0x1f,0x04,0xab,0x0b,0xad,0x8a,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x34,0x81,0x92,0x1e },
        { 0x02,0x04,0xab,0x0b,0xad,0x8a,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x34,0x81,0x92,0x1e,0x94,0x73,0x35,0xd0,0x43,0x41,0xb7,0xd8,0x45,0x00,0x12,0xfe,0x98,0xf2,0x2d,0x17,0x1f },
        { 0x02,0x04,0x53,0x2d,0xb9,0xa3,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x57,0x8b,0xaa,0x3f },
        { 0x14,0xc5,0xb6,0x70,0x61,0x41,0xb7,0xd8,0x45,0x60,0x12,0xfe,0x98,0xd0,0x6e,0xba,0x63,0x04,0x53,0x2d,0xb9,0xa3,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x57,0x8b,0xaa,0x3f },
        { 0x02,0x04,0x53,0x2d,0xb9,0xa3,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x57,0x8b,0xaa,0x3f,0x94,0xc5,0xb6,0x70,0x61,0x41,0xb7,0xd8,0x45,0x60,0x12,0xfe,0x98,0xd0,0x6e,0xba,0x63 },
        { 0x00,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x03,0x10,0x01,0x00,0x00,0x00,0x00 },
        { 0x00,0x04,0x61,0x2a,0x7c,0x1d,0x49,0xbf,0x7b,0x9c,0x3b,0xb0,0x8a,0x5e,0x89,0xf1,0xd6,0xa4,0x11,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x03 },
        { 0x00,0x04,0x61,0x2a,0x7c,0x1d,0x49,0xbf,0x7b,0x9c,0x3b,0xb0,0x8a,0x5e,0x89,0xf1,0xd6,0xa4,0x90,0x01,0x00,0x00,0x00,0x00 },
        { 0x17,0xff,0x01,0x00,0x00,0x00,0x00 },
        { 0x17,0x43,0x08,0x00,0x00,0x00,0x0e,0x24,0x00,0x73,0x00,0x79,0x00,0x73,0x00,0x64,0x00,0x65,0x00,0x66,0x00,0x01,0x00,0x00,0x00,0x00 },
        { 0x92,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x03,0x04,0x61,0x2a,0x7c,0x1d,0x49,0xbf,0x7b,0x9c,0x3b,0xb0,0x8a,0x5e,0x89,0xf1,0xd6,0xa4 },
        { 0x12,0x04,0x61,0x2a,0x7c,0x1d,0x49,0xbf,0x7b,0x9c,0x3b,0xb0,0x8a,0x5e,0x89,0xf1,0xd6,0xa4 },
        { 0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x03 },
        { 0x01,0x04,0x61,0x2a,0x7c,0x1d,0x49,0xbf,0x7b,0x9c,0x3b,0xb0,0x8a,0x5e,0x89,0xf1,0xd6,0xa4,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x03 },
        { 0x81,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x03,0x04,0x61,0x2a,0x7c,0x1d,0x49,0xbf,0x7b,0x9c,0x3b,0xb0,0x8a,0x5e,0x89,0xf1,0xd6,0xa4 },
        { 0x02,0x04,0x53,0x2d,0xb9,0xa3,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x57,0x8b,0xaa,0x3f,0x10,0x01,0x00,0x00,0x00,0x01 },
        { 0x00,0x04,0x61,0x2a,0x7c,0x1d,0x49,0xbf,0x7b,0x9c,0x3b,0xb0,0x8a,0x5e,0x89,0xf1,0xd6,0xa4,0x11,0x04,0x53,0x2d,0xb9,0xa3,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x57,0x8b,0xaa,0x3f },
        { 0x00,0x04,0x61,0x2a,0x7c,0x1d,0x49,0xbf,0x7b,0x9c,0x3b,0xb0,0x8a,0x5e,0x89,0xf1,0xd6,0xa4,0x90,0x01,0x00,0x00,0x00,0x01 },
        { 0x17,0xff,0x01,0x00,0x00,0x00,0x01 },
        { 0x17,0x43,0x08,0x00,0x00,0x00,0x0e,0x24,0x00,0x73,0x00,0x79,0x00,0x73,0x00,0x64,0x00,0x65,0x00,0x66,0x00,0x01,0x00,0x00,0x00,0x01 },
        { 0x02,0x04,0x53,0x2d,0xb9,0xa3,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x57,0x8b,0xaa,0x3f,0x10,0x01,0x00,0x00,0x00,0x02 },
        { 0x00,0x04,0x50,0xaa,0x2b,0xa8,0x4d,0xc3,0x95,0x14,0xfb,0x6e,0xbd,0xc1,0xfb,0x2d,0xb7,0x06,0x11,0x04,0x53,0x2d,0xb9,0xa3,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x57,0x8b,0xaa,0x3f },
        { 0x00,0x04,0x50,0xaa,0x2b,0xa8,0x4d,0xc3,0x95,0x14,0xfb,0x6e,0xbd,0xc1,0xfb,0x2d,0xb7,0x06,0x90,0x01,0x00,0x00,0x00,0x02 },
        { 0x17,0xff,0x01,0x00,0x00,0x00,0x02 },
        { 0x17,0x43,0x08,0x00,0x00,0x00,0x06,0x69,0x00,0x73,0x00,0x61,0x00,0x01,0x00,0x00,0x00,0x02 },
        { 0x02,0x04,0xab,0x0b,0xad,0x8a,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x34,0x81,0x92,0x1e,0x10,0x01,0x00,0x00,0x00,0x03 },
        { 0x00,0x04,0x61,0x2a,0x7c,0x1d,0x49,0xbf,0x7b,0x9c,0x3b,0xb0,0x8a,0x5e,0x89,0xf1,0xd6,0xa4,0x11,0x04,0xab,0x0b,0xad,0x8a,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x34,0x81,0x92,0x1e },
        { 0x00,0x04,0x61,0x2a,0x7c,0x1d,0x49,0xbf,0x7b,0x9c,0x3b,0xb0,0x8a,0x5e,0x89,0xf1,0xd6,0xa4,0x90,0x01,0x00,0x00,0x00,0x03 },
        { 0x17,0xff,0x01,0x00,0x00,0x00,0x03 },
        { 0x17,0x43,0x08,0x00,0x00,0x00,0x0e,0x24,0x00,0x73,0x00,0x79,0x00,0x73,0x00,0x64,0x00,0x65,0x00,0x66,0x00,0x01,0x00,0x00,0x00,0x03 },
        { 0x02,0x04,0xab,0x0b,0xad,0x8a,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x34,0x81,0x92,0x1e,0x10,0x01,0x00,0x00,0x00,0x04 },
        { 0x00,0x04,0x50,0xaa,0x2b,0xa8,0x4d,0xc3,0x95,0x14,0xfb,0x6e,0xbd,0xc1,0xfb,0x2d,0xb7,0x06,0x11,0x04,0xab,0x0b,0xad,0x8a,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x34,0x81,0x92,0x1e },
        { 0x00,0x04,0x50,0xaa,0x2b,0xa8,0x4d,0xc3,0x95,0x14,0xfb,0x6e,0xbd,0xc1,0xfb,0x2d,0xb7,0x06,0x90,0x01,0x00,0x00,0x00,0x04 },
        { 0x17,0xff,0x01,0x00,0x00,0x00,0x04 },
        { 0x17,0x43,0x08,0x00,0x00,0x00,0x0c,0x70,0x00,0x61,0x00,0x72,0x00,0x74,0x00,0x6f,0x00,0x66,0x00,0x01,0x00,0x00,0x00,0x04 },
        { 0x02,0x04,0xf4,0x73,0x6c,0xaf,0x41,0x99,0xd8,0x45,0x80,0x12,0xfe,0x98,0x30,0x64,0x99,0x84 },
        { 0x92,0x04,0x3c,0x54,0xdc,0x08,0x49,0x23,0x95,0x89,0xa5,0x6b,0xb0,0x9e,0x1b,0x7b,0x1c,0xde,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x12,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x04,0x3c,0x54,0xdc,0x08,0x49,0x23,0x95,0x89,0xa5,0x6b,0xb0,0x9e,0x1b,0x7b,0x1c,0xde },
        { 0x01,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa,0x04,0x3c,0x54,0xdc,0x08,0x49,0x23,0x95,0x89,0xa5,0x6b,0xb0,0x9e,0x1b,0x7b,0x1c,0xde },
        { 0x81,0x04,0x3c,0x54,0xdc,0x08,0x49,0x23,0x95,0x89,0xa5,0x6b,0xb0,0x9e,0x1b,0x7b,0x1c,0xde,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x92,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x12,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x01,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x81,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x14,0x54,0x3a,0xb7,0xca,0x43,0xc4,0x7d,0x73,0xe7,0xc2,0x35,0x94,0x6d,0xaa,0x9a,0x68,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x06 },
        { 0x00,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x06,0x94,0x54,0x3a,0xb7,0xca,0x43,0xc4,0x7d,0x73,0xe7,0xc2,0x35,0x94,0x6d,0xaa,0x9a,0x68 },
        { 0x14,0x54,0x3a,0xb7,0xca,0x43,0xc4,0x7d,0x73,0xe7,0xc2,0x35,0x94,0x6d,0xaa,0x9a,0x68,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x06 },
        { 0x00,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x06,0x94,0x54,0x3a,0xb7,0xca,0x43,0xc4,0x7d,0x73,0xe7,0xc2,0x35,0x94,0x6d,0xaa,0x9a,0x68 },
        { 0x92,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x06,0x04,0x3c,0x54,0xdc,0x08,0x49,0x23,0x95,0x89,0xa5,0x6b,0xb0,0x9e,0x1b,0x7b,0x1c,0xde },
        { 0x12,0x04,0x3c,0x54,0xdc,0x08,0x49,0x23,0x95,0x89,0xa5,0x6b,0xb0,0x9e,0x1b,0x7b,0x1c,0xde },
        { 0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x06 },
        { 0x01,0x04,0x3c,0x54,0xdc,0x08,0x49,0x23,0x95,0x89,0xa5,0x6b,0xb0,0x9e,0x1b,0x7b,0x1c,0xde,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x06 },
        { 0x81,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x06,0x04,0x3c,0x54,0xdc,0x08,0x49,0x23,0x95,0x89,0xa5,0x6b,0xb0,0x9e,0x1b,0x7b,0x1c,0xde },
        { 0x92,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x12,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a },
        { 0x01,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a },
        { 0x81,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x92,0x04,0x27,0x0d,0x76,0x0f,0x48,0x2c,0x57,0x0d,0x7a,0xca,0xb7,0x93,0x49,0xf4,0xfa,0x1c,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a },
        { 0x12,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a },
        { 0x04,0x27,0x0d,0x76,0x0f,0x48,0x2c,0x57,0x0d,0x7a,0xca,0xb7,0x93,0x49,0xf4,0xfa,0x1c },
        { 0x92,0x04,0x27,0x0d,0x76,0x0f,0x48,0x2c,0x57,0x0d,0x7a,0xca,0xb7,0x93,0x49,0xf4,0xfa,0x1c,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x12,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x04,0x27,0x0d,0x76,0x0f,0x48,0x2c,0x57,0x0d,0x7a,0xca,0xb7,0x93,0x49,0xf4,0xfa,0x1c },
        { 0x01,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a,0x04,0x27,0x0d,0x76,0x0f,0x48,0x2c,0x57,0x0d,0x7a,0xca,0xb7,0x93,0x49,0xf4,0xfa,0x1c },
        { 0x81,0x04,0x27,0x0d,0x76,0x0f,0x48,0x2c,0x57,0x0d,0x7a,0xca,0xb7,0x93,0x49,0xf4,0xfa,0x1c,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a },
        { 0x92,0x04,0xce,0x92,0xcf,0x4c,0x4a,0x2b,0xaf,0xc3,0x5a,0x76,0xa3,0xa8,0xbe,0x53,0x8b,0x17,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a },
        { 0x12,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a },
        { 0x04,0xce,0x92,0xcf,0x4c,0x4a,0x2b,0xaf,0xc3,0x5a,0x76,0xa3,0xa8,0xbe,0x53,0x8b,0x17 },
        { 0x92,0x04,0xce,0x92,0xcf,0x4c,0x4a,0x2b,0xaf,0xc3,0x5a,0x76,0xa3,0xa8,0xbe,0x53,0x8b,0x17,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x12,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x04,0xce,0x92,0xcf,0x4c,0x4a,0x2b,0xaf,0xc3,0x5a,0x76,0xa3,0xa8,0xbe,0x53,0x8b,0x17 },
        { 0x01,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a,0x04,0xce,0x92,0xcf,0x4c,0x4a,0x2b,0xaf,0xc3,0x5a,0x76,0xa3,0xa8,0xbe,0x53,0x8b,0x17 },
        { 0x81,0x04,0xce,0x92,0xcf,0x4c,0x4a,0x2b,0xaf,0xc3,0x5a,0x76,0xa3,0xa8,0xbe,0x53,0x8b,0x17,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a },
        { 0x92,0x04,0x3a,0xcb,0xec,0x38,0x46,0x5c,0x6d,0x20,0xba,0xf9,0x1c,0xbd,0xdd,0xda,0x99,0x91,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x12,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x04,0x3a,0xcb,0xec,0x38,0x46,0x5c,0x6d,0x20,0xba,0xf9,0x1c,0xbd,0xdd,0xda,0x99,0x91 },
        { 0x01,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf,0x04,0x3a,0xcb,0xec,0x38,0x46,0x5c,0x6d,0x20,0xba,0xf9,0x1c,0xbd,0xdd,0xda,0x99,0x91 },
        { 0x81,0x04,0x3a,0xcb,0xec,0x38,0x46,0x5c,0x6d,0x20,0xba,0xf9,0x1c,0xbd,0xdd,0xda,0x99,0x91,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x92,0x04,0xab,0x86,0x48,0xd1,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0x3d,0x8d,0x5e,0x07,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a },
        { 0x12,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a },
        { 0x04,0xab,0x86,0x48,0xd1,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0x3d,0x8d,0x5e,0x07 },
        { 0x92,0x04,0xab,0x86,0x48,0xd1,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0x3d,0x8d,0x5e,0x07,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x12,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x04,0xab,0x86,0x48,0xd1,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0x3d,0x8d,0x5e,0x07 },
        { 0x01,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a,0x04,0xab,0x86,0x48,0xd1,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0x3d,0x8d,0x5e,0x07 },
        { 0x81,0x04,0xab,0x86,0x48,0xd1,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0x3d,0x8d,0x5e,0x07,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a },
        { 0x92,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0c,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x12,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0c },
        { 0x01,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0c },
        { 0x81,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0c,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x92,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x12,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x01,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x81,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x92,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e,0x04,0xab,0x86,0x48,0xd1,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0x3d,0x8d,0x5e,0x07 },
        { 0x12,0x04,0xab,0x86,0x48,0xd1,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0x3d,0x8d,0x5e,0x07 },
        { 0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e },
        { 0x92,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a },
        { 0x12,0x04,0x19,0xb8,0x2c,0x7a,0x4d,0x45,0x95,0x6d,0x92,0xe5,0x65,0xa0,0x04,0x84,0xf2,0x2a },
        { 0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e },
        { 0x92,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x12,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e },
        { 0x01,0x04,0xab,0x86,0x48,0xd1,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0x3d,0x8d,0x5e,0x07,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e },
        { 0x81,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e,0x04,0xab,0x86,0x48,0xd1,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0x3d,0x8d,0x5e,0x07 },
        { 0x02,0x05,0x53,0x2d,0xb9,0xa3,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x57,0x8b,0xaa,0x3f,0x00,0x00,0x00,0x00 },
        { 0x92,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x12,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e },
        { 0x92,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x12,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e },
        { 0x01,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e },
        { 0x81,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x92,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0f,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x12,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0f },
        { 0x92,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0f,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x12,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0f },
        { 0x01,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0f },
        { 0x81,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0f,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x00,0x04,0x81,0x43,0x86,0xbe,0x49,0x2a,0x71,0xc0,0x9f,0x28,0x04,0x8c,0x71,0x14,0x28,0x40,0x10,0x01,0x00,0x00,0x00,0x05 },
        { 0x00,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e,0x11,0x04,0x81,0x43,0x86,0xbe,0x49,0x2a,0x71,0xc0,0x9f,0x28,0x04,0x8c,0x71,0x14,0x28,0x40 },
        { 0x00,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e,0x90,0x01,0x00,0x00,0x00,0x05 },
        { 0x17,0xff,0x01,0x00,0x00,0x00,0x05 },
        { 0x17,0x43,0x08,0x00,0x00,0x00,0x0e,0x40,0x04,0x43,0x04,0x41,0x04,0x41,0x04,0x3a,0x04,0x38,0x04,0x39,0x04,0x01,0x00,0x00,0x00,0x05 },
        { 0x92,0x04,0x81,0x43,0x86,0xbe,0x49,0x2a,0x71,0xc0,0x9f,0x28,0x04,0x8c,0x71,0x14,0x28,0x40,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0c },
        { 0x12,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0c },
        { 0x04,0x81,0x43,0x86,0xbe,0x49,0x2a,0x71,0xc0,0x9f,0x28,0x04,0x8c,0x71,0x14,0x28,0x40 },
        { 0x92,0x04,0x81,0x43,0x86,0xbe,0x49,0x2a,0x71,0xc0,0x9f,0x28,0x04,0x8c,0x71,0x14,0x28,0x40,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x12,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x04,0x81,0x43,0x86,0xbe,0x49,0x2a,0x71,0xc0,0x9f,0x28,0x04,0x8c,0x71,0x14,0x28,0x40 },
        { 0x01,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0c,0x04,0x81,0x43,0x86,0xbe,0x49,0x2a,0x71,0xc0,0x9f,0x28,0x04,0x8c,0x71,0x14,0x28,0x40 },
        { 0x81,0x04,0x81,0x43,0x86,0xbe,0x49,0x2a,0x71,0xc0,0x9f,0x28,0x04,0x8c,0x71,0x14,0x28,0x40,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0c },
        { 0x02,0x05,0x53,0x2d,0xb9,0xa3,0x41,0xa1,0xd8,0x45,0x00,0x12,0xfe,0x98,0x57,0x8b,0xaa,0x3f,0x00,0x00,0x00,0x01 },
        { 0x00,0x04,0x31,0x82,0x43,0x6b,0x46,0xa0,0x3c,0xd1,0x22,0x56,0xe2,0xba,0x69,0xd1,0x07,0xc4,0x10,0x01,0x00,0x00,0x00,0x06 },
        { 0x00,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e,0x11,0x04,0x31,0x82,0x43,0x6b,0x46,0xa0,0x3c,0xd1,0x22,0x56,0xe2,0xba,0x69,0xd1,0x07,0xc4 },
        { 0x00,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e,0x90,0x01,0x00,0x00,0x00,0x06 },
        { 0x17,0xff,0x01,0x00,0x00,0x00,0x06 },
        { 0x17,0x43,0x08,0x00,0x00,0x00,0x0c,0x33,0x04,0x3b,0x04,0x30,0x04,0x33,0x04,0x3e,0x04,0x3b,0x04,0x01,0x00,0x00,0x00,0x06 },
        { 0x00,0x04,0x31,0x82,0x43,0x6b,0x46,0xa0,0x3c,0xd1,0x22,0x56,0xe2,0xba,0x69,0xd1,0x07,0xc4,0x10,0x01,0x00,0x00,0x00,0x07 },
        { 0x00,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0f,0x11,0x04,0x31,0x82,0x43,0x6b,0x46,0xa0,0x3c,0xd1,0x22,0x56,0xe2,0xba,0x69,0xd1,0x07,0xc4 },
        { 0x00,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0f,0x90,0x01,0x00,0x00,0x00,0x07 },
        { 0x17,0xff,0x01,0x00,0x00,0x00,0x07 },
        { 0x17,0x43,0x08,0x00,0x00,0x00,0x08,0x76,0x00,0x65,0x00,0x72,0x00,0x62,0x00,0x01,0x00,0x00,0x00,0x07 },
        { 0x92,0x04,0x31,0x82,0x43,0x6b,0x46,0xa0,0x3c,0xd1,0x22,0x56,0xe2,0xba,0x69,0xd1,0x07,0xc4,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x12,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x04,0x31,0x82,0x43,0x6b,0x46,0xa0,0x3c,0xd1,0x22,0x56,0xe2,0xba,0x69,0xd1,0x07,0xc4 },
        { 0x92,0x04,0x31,0x82,0x43,0x6b,0x46,0xa0,0x3c,0xd1,0x22,0x56,0xe2,0xba,0x69,0xd1,0x07,0xc4,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x12,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x04,0x31,0x82,0x43,0x6b,0x46,0xa0,0x3c,0xd1,0x22,0x56,0xe2,0xba,0x69,0xd1,0x07,0xc4 },
        { 0x01,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e,0x04,0x31,0x82,0x43,0x6b,0x46,0xa0,0x3c,0xd1,0x22,0x56,0xe2,0xba,0x69,0xd1,0x07,0xc4 },
        { 0x81,0x04,0x31,0x82,0x43,0x6b,0x46,0xa0,0x3c,0xd1,0x22,0x56,0xe2,0xba,0x69,0xd1,0x07,0xc4,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x00, 0x04, 0x1d, 0xbf, 0xf4, 0x97, 0x40, 0xab, 0xde, 0xef, 0xcc, 0xe2, 0xd8, 0xbf, 0xad, 0x28, 0xbf, 0x8d, 0x10, 0x01, 0x00, 0x00, 0x00, 0x08 },
        { 0x00,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e,0x11,0x04,0x1d,0xbf,0xf4,0x97,0x40,0xab,0xde,0xef,0xcc,0xe2,0xd8,0xbf,0xad,0x28,0xbf,0x8d },
        { 0x00,0x04,0xa9,0x3d,0xc9,0xd9,0x45,0x33,0x21,0x73,0xc3,0xea,0x3a,0x8d,0x83,0x79,0xbb,0x6e,0x90,0x01,0x00,0x00,0x00,0x08 },
        { 0x17,0xff,0x01,0x00,0x00,0x00,0x08 },
        { 0x17,0x43,0x08,0x00,0x00,0x00,0x1e,0x41,0x04,0x43,0x04,0x49,0x04,0x35,0x04,0x41,0x04,0x42,0x04,0x32,0x04,0x38,0x04,0x42,0x04,0x35,0x04,0x3b,0x04,0x4c,0x04,0x3d,0x04,0x3e,0x04,0x35,0x04,0x01,0x00,0x00,0x00,0x08 },
        { 0x00,0x04,0x1d,0xbf,0xf4,0x97,0x40,0xab,0xde,0xef,0xcc,0xe2,0xd8,0xbf,0xad,0x28,0xbf,0x8d,0x10,0x01,0x00,0x00,0x00,0x09 },
        { 0x00,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0f,0x11,0x04,0x1d,0xbf,0xf4,0x97,0x40,0xab,0xde,0xef,0xcc,0xe2,0xd8,0xbf,0xad,0x28,0xbf,0x8d },
        { 0x00,0x05,0x10,0x50,0x12,0xc1,0x5b,0xa1,0x0e,0x9e,0x16,0xdc,0xef,0x4c,0x6e,0x34,0x9b,0x96,0x00,0x00,0x00,0x0f,0x90,0x01,0x00,0x00,0x00,0x09 },
        { 0x17,0xff,0x01,0x00,0x00,0x00,0x09 },
        { 0x17,0x43,0x08,0x00,0x00,0x00,0x08,0x6e,0x00,0x6f,0x00,0x75,0x00,0x6e,0x00,0x01,0x00,0x00,0x00,0x09 },
        { 0x92,0x04,0x1d,0xbf,0xf4,0x97,0x40,0xab,0xde,0xef,0xcc,0xe2,0xd8,0xbf,0xad,0x28,0xbf,0x8d,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x12,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x04,0x1d,0xbf,0xf4,0x97,0x40,0xab,0xde,0xef,0xcc,0xe2,0xd8,0xbf,0xad,0x28,0xbf,0x8d },
        { 0x92,0x04,0x1d,0xbf,0xf4,0x97,0x40,0xab,0xde,0xef,0xcc,0xe2,0xd8,0xbf,0xad,0x28,0xbf,0x8d,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x12,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x04,0x1d,0xbf,0xf4,0x97,0x40,0xab,0xde,0xef,0xcc,0xe2,0xd8,0xbf,0xad,0x28,0xbf,0x8d },
        { 0x01,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e,0x04,0x1d,0xbf,0xf4,0x97,0x40,0xab,0xde,0xef,0xcc,0xe2,0xd8,0xbf,0xad,0x28,0xbf,0x8d },
        { 0x81,0x04,0x1d,0xbf,0xf4,0x97,0x40,0xab,0xde,0xef,0xcc,0xe2,0xd8,0xbf,0xad,0x28,0xbf,0x8d,0x04,0x42,0x72,0x0a,0xaa,0x41,0xfb,0xd8,0x45,0x00,0x12,0xfe,0x98,0xc5,0x0a,0x58,0x0e },
        { 0x92,0x04,0xca,0xde,0x18,0x41,0x48,0x61,0xfc,0x3f,0x3c,0x01,0xc9,0xa1,0xda,0x7e,0x04,0x02,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x12,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x04,0xca,0xde,0x18,0x41,0x48,0x61,0xfc,0x3f,0x3c,0x01,0xc9,0xa1,0xda,0x7e,0x04,0x02 },
        { 0x01,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf,0x04,0xca,0xde,0x18,0x41,0x48,0x61,0xfc,0x3f,0x3c,0x01,0xc9,0xa1,0xda,0x7e,0x04,0x02 },
        { 0x81,0x04,0xca,0xde,0x18,0x41,0x48,0x61,0xfc,0x3f,0x3c,0x01,0xc9,0xa1,0xda,0x7e,0x04,0x02,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x92,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x12,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4 },
        { 0x92,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x12,0x04,0xf5,0x02,0x87,0x52,0x41,0xa1,0xd8,0x45,0xc0,0x12,0xfe,0x98,0x9c,0xbf,0x89,0xaa },
        { 0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4 },
        { 0x01,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4 },
        { 0x81,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x92,0x04,0x5d,0x48,0x29,0x4b,0x40,0xad,0xee,0x40,0xe3,0x4c,0x0b,0x9f,0x84,0x37,0x44,0xf1,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4 },
        { 0x12,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4 },
        { 0x04,0x5d,0x48,0x29,0x4b,0x40,0xad,0xee,0x40,0xe3,0x4c,0x0b,0x9f,0x84,0x37,0x44,0xf1 },
        { 0x01,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4,0x04,0x5d,0x48,0x29,0x4b,0x40,0xad,0xee,0x40,0xe3,0x4c,0x0b,0x9f,0x84,0x37,0x44,0xf1 },
        { 0x81,0x04,0x5d,0x48,0x29,0x4b,0x40,0xad,0xee,0x40,0xe3,0x4c,0x0b,0x9f,0x84,0x37,0x44,0xf1,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4 },
        { 0x92,0x04,0xb4,0xb4,0xb9,0x11,0x43,0x6b,0x76,0x64,0x82,0x56,0x89,0x8a,0xe7,0x9f,0x4c,0x48,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4 },
        { 0x12,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4 },
        { 0x04,0xb4,0xb4,0xb9,0x11,0x43,0x6b,0x76,0x64,0x82,0x56,0x89,0x8a,0xe7,0x9f,0x4c,0x48 },
        { 0x01,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4,0x04,0xb4,0xb4,0xb9,0x11,0x43,0x6b,0x76,0x64,0x82,0x56,0x89,0x8a,0xe7,0x9f,0x4c,0x48 },
        { 0x81,0x04,0xb4,0xb4,0xb9,0x11,0x43,0x6b,0x76,0x64,0x82,0x56,0x89,0x8a,0xe7,0x9f,0x4c,0x48,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4 },
        { 0x14,0xc5,0xb6,0x70,0x61,0x41,0xb7,0xd8,0x45,0x60,0x12,0xfe,0x98,0xd0,0x6e,0xba,0x63,0x04,0xbd,0x57,0x9e,0xca,0x4c,0x14,0xf6,0x35,0xcc,0x16,0xe5,0x9c,0x5b,0x02,0xa0,0xbe },
        { 0x00,0x04,0xbd,0x57,0x9e,0xca,0x4c,0x14,0xf6,0x35,0xcc,0x16,0xe5,0x9c,0x5b,0x02,0xa0,0xbe,0x94,0xc5,0xb6,0x70,0x61,0x41,0xb7,0xd8,0x45,0x60,0x12,0xfe,0x98,0xd0,0x6e,0xba,0x63 },
        { 0x92,0x04,0xbd,0x57,0x9e,0xca,0x4c,0x14,0xf6,0x35,0xcc,0x16,0xe5,0x9c,0x5b,0x02,0xa0,0xbe,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x12,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x04,0xbd,0x57,0x9e,0xca,0x4c,0x14,0xf6,0x35,0xcc,0x16,0xe5,0x9c,0x5b,0x02,0xa0,0xbe },
        { 0x01,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf,0x04,0xbd,0x57,0x9e,0xca,0x4c,0x14,0xf6,0x35,0xcc,0x16,0xe5,0x9c,0x5b,0x02,0xa0,0xbe },
        { 0x81,0x04,0xbd,0x57,0x9e,0xca,0x4c,0x14,0xf6,0x35,0xcc,0x16,0xe5,0x9c,0x5b,0x02,0xa0,0xbe,0x04,0x3a,0xbf,0x32,0x1d,0x43,0xad,0xd8,0x48,0xc1,0x63,0x9d,0x9d,0x8b,0x56,0x26,0xcf },
        { 0x00,0x04,0x00,0xe8,0x0e,0xc7,0x4e,0x3a,0x44,0x0f,0x2e,0xb0,0x12,0xb3,0x71,0x95,0xbc,0xf1,0x10,0x01,0x00,0x00,0x00,0x0a },
        { 0x00,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4,0x11,0x04,0x00,0xe8,0x0e,0xc7,0x4e,0x3a,0x44,0x0f,0x2e,0xb0,0x12,0xb3,0x71,0x95,0xbc,0xf1 },
        { 0x00,0x04,0x25,0xe4,0xda,0xfe,0x4f,0x04,0xa7,0xf7,0x24,0xdf,0xc8,0x86,0x45,0x95,0x9d,0xd4,0x90,0x01,0x00,0x00,0x00,0x0a },
        { 0x17,0xff,0x01,0x00,0x00,0x00,0x0a },
        { 0x17,0x80,0x04,0x5d,0x48,0x29,0x4b,0x40,0xad,0xee,0x40,0xe3,0x4c,0x0b,0x9f,0x84,0x37,0x44,0xf1,0x01,0x00,0x00,0x00,0x0a },
        { 0x17,0x00,0x04,0x5d,0x48,0x29,0x4b,0x40,0xad,0xee,0x40,0xe3,0x4c,0x0b,0x9f,0x84,0x37,0x44,0xf1,0x01,0x00,0x00,0x00,0x0a },

    };
    typedef std::pair<atom_string_t, double> p_t;
    std::map<atom_string_t, double> test_values;

    auto tmngr = OP::trie::SegmentManager::create_new<EventSourcingSegmentManager>(test_file_name,
        OP::trie::SegmentOptions()
        .segment_size(0x110000));
    typedef Trie<EventSourcingSegmentManager, double> trie_t;
    std::shared_ptr<trie_t> trie = trie_t::create_new(tmngr);
    const atom_string_t to_erase
    { 0x17, 0x80, 0x04, 0x5d, 0x48, 0x29, 0x4b, 0x40, 0xad, 0xee, 0x40, 0xe3, 0x4c, 0x0b, 0x9f, 0x84, 0x37, 0x44, 0xf1, 0x01, 0x00, 0x00, 0x00, 0x0a };
    const atom_string_t to_add
    { 0x17,0x00,0x04,0x5d,0x48,0x29,0x4b,0x40,0xad,0xee,0x40,0xe3,0x4c,0x0b,0x9f,0x84,0x37,0x44,0xf1,0x01,0x00,0x00,0x00,0x0a };

    /*const atom_string_t
        comm_suffix{ 0x17,0x43,0x08,0x00,0x00,0x00,0x1e,0x41,0x04,0x43,0x04,0x49,0x04,0x35,0x04,0x41,0x04,0x42,0x04,0x32,0x04,0x38,0x04,0x42,0x04,0x35,0x04,0x3b,0x04,0x4c,0x04,0x3d,0x04,0x3e,0x04,0x35,0x04,0x01,0x00,0x00,0x00,0x08 };
    for (int i = 0; i < 10;++i) {
        atom_string_t s{ (unsigned char)i };
        //trie->insert(s, 10);
        //test_values.emplace(s, 10);
        s += comm_suffix;
        trie->insert(s, 20);
        test_values.emplace(s, 20);
    } */


    std::for_each(std::begin(source_seq), std::end(source_seq), [&](const atom_string_t& s) {
        trie->insert(s, 0);
        test_values.emplace(s, 0);
        });
    compare_containers(tresult, *trie, test_values);

    trie->erase(trie->find(to_erase));
    test_values.erase(to_erase);

    compare_containers(tresult, *trie, test_values);

    tresult.assert_that<equals>(trie->end(), trie->find(to_erase),
        OP_CODE_DETAILS(<< "erase failed"));
    trie->insert(to_add, 20);
    test_values.emplace(to_add, 20);

    compare_containers(tresult, *trie, test_values);
}
//
////*************************************************
//
//
//

static auto& module_suite = OP::utest::default_test_suite("Trie.range")

.declare("subtree of prefix", test_TrieSubtree)
.declare("lambda on subtree", test_TrieSubtreeLambdaOperations)
.declare("flatten", test_Flatten)
////.declare("section range", test_TrieSectionRange)
////.declare("all_prefixes_range", test_AllPrefixesRange)
.declare("child", test_ChildSelector)
.declare("iterate all by range", test_Range)
.declare("test native ranges of Trie", test_NativeRangeSupport)
.declare("override_join_range", test_JoinRangeOverride)
.declare("ISSUE_0001", test_ISSUE_0001)
//
;
}//ns:""